<?xml version="1.0" encoding="utf-8"?>
<pysystest 
	authors="userid1, userid2, Joe Bloggs" created="1999-12-31"
>
	
	<!-- Test titles should be concise but give a clear idea of what is in scope for this testcase. 

	Good titles make it easy to find the test you need even when you have 100s/1000s of tests. 
	Tests can be sorted by title so try to use common prefixes (e.g. ``Category: Title``) to group related tests 
	together, and run ``pysys print -s=title`` to see how your title looks alongside the existing titles. 
	
	Titles need to be human readable at-a-glance, so don't put ids (e.g. bug tracking numbers) in the title; 
	the "purpose" or "requirements" are a better place for those details. 
	
	The title can also be specified without XML as: __pysystest_title__ = """ ... """ 
	-->
	<title>My foobar tool - Argument parsing success and error cases</title>

	<!-- The purpose can also be specified without XML as: __pysystest_purpose__ = """ ... """
	-->
	<purpose><![CDATA[
		This is a good place for a fuller description of what is in and 
		out of scope for this particular testcase. 
		
	]]></purpose>

	<!-- Comment/uncomment this to mark this test as skipped, which will stop it from executing. -->
	<skipped reason="This test is skipped until Bug-1234 is fixed"/>
	
	<!-- Specify the groups that this test will be tagged with, allowing them to be selected 
	for inclusion/exclusion in test runs. Groups are usually named in camelCase. 
	These groups are in addition to any from parent pysysdirconfigs if inherit=true. 
	
	The disableCoverage group is a special group used by code coverage writers to ensure coverage tools are disabled for 
	tests that are performance-critical. 
	-->
	<groups inherit="true" groups="performance, disableCoverage"/>

	<!-- Specify the list of modes this test can be run in. 
	
	Like test ids, mode names are usually TitleCase, with multiple dimensions delimited by an ``_`` underscore, 
	e.g. ``CompressionGZip_AuthNone``.
	
	Test modes are configured with a Python lambda that returns a list of modes, using a single parameter which is 
	an instance of ``pysys.config.descriptor.TestModesConfigHelper`` providing access to the inherited modes (and other 
	useful functions/fields). Each mode in the returned list is defined by a dictionary containing parameters to be set 
	on the test object and/or a ``mode`` name. If the mode name is not explicitly provided, a default mode name is 
	generated by concatenating the parameter values with ``_`` (with a ``paramName=`` prefix for any numeric/boolean 
	values).
	
	In your Python lambda you can return a simple list of modes, or combine your own modes with inherited modes 
	defined by parent pysysdirconfigs. You can also use the power of Python list comprehensions to exclude certain modes, 
	perhaps based on dynamic information such as the operating system. Project properties can be accessed 
	using ``helper.project.PROPERTY_NAME``. Avoid expensive operations such as reading the file system from your lambda 
	if possible. 
	
	The first listed mode is the "primary" mode, which is the one that is used by default when executing tests with 
	no ``-m`` argument. 
	
	It's often useful to combine multiple mode 'dimensions', for example all the combinations of a list of web browsers 
	with a list of databases, or compression methods and authentication types. Rather than writing out every combination 
	manually, you can use the function ``helper.combineModeDimensions`` to automatically generate all combinations. 

	Modes can be used to define similar subtests that share the same test class logic, for example testing your 
	application's output when given various different input test vectors. For this common use case, if you already (or 
	plan to) define multiple execution modes inherited in a parent directory, you usually want to 
	use ``helper.combineModeDimensions(helper.inheritedModes, [...])`` in your test so that each of the subtests you 
	define in that second argument are executed in each of the inherited modes (if any). 

	A test can use self.mode to find out which mode it is executing and/or self.mode.params to access any parameters.
	
	-->
	<modes>
		lambda helper: [
				mode for mode in 
					helper.combineModeDimensions( # Takes any number of mode lists as arguments and returns a single combined mode list
						helper.inheritedModes,
						{
								'CompressionNone': {'compressionType':None, 'isPrimary':True}, 
								'CompressionGZip': {'compressionType':'gzip'},
						}, 
						[
							{'auth':None}, # Mode name is optional
							{'auth':'OS'}, # In practice auth=OS modes will always be excluded since MyFunkyOS is a fictional OS
						], 
						
						# By default only the first mode in each list is "primary", so the test will only run in that one mode by 
						# default during local development (unless you supply a ``--modes`` or ``--ci`` argument). This is optimal when 
						# using modes to validate the same behaviour/conditions in different execution environments e.g. 
						# browsers/databases etc. However when using modes to validate different *behaviours/conditions* (e.g. testing 
						# out different command line options) using a single PySysTest class, then you should have all your modes as 
						# "primary" as you want all of them to execute by default in a quick local test run. 
						helper.makeAllPrimary(
							{
								'Usage':        {'cmd': ['--help'], 'expectedExitStatus':'==0'}, 
								'BadPort':      {'cmd': ['--port', '-1'],  'expectedExitStatus':'!=0'}, 
								'MissingPort':  {'cmd': [],  'expectedExitStatus':'!=0'}, 
							}), 
						)
				# This is Python list comprehension syntax for filtering the items in the list
				if (mode['auth'] != 'OS' or helper.import_module('sys').platform == 'MyFunkyOS')
			]
	</modes>

	<!--
	NB: Older (pre-2.0) PySys projects used a more basic and limited syntax for specifying modes:
	
		<modes inherit="true">
			<mode>CompressionNone</mode>
			<mode>CompressionGZip</mode>
		</modes>
	-->
	
	<!-- Specify as a floating point number an indicator of when to run the tests under 
	this directory, relative to other tests/directories with a higher or lower hint. 
	Empty string hint="" means inherit. The default priority is 0.0 so set the hint to a higher 
	value to execute tests later, or a negative value to execute tests earlier. 
	-->
	<execution-order hint="+100.0"/>
	
	<!-- By convention the test class uses module="run.py" located in the test directory, but 
	it is possible to use a different path (even an absolute path). If you want to use a single 
	Python class for lots of tests rather, omit the module= attribute and make sure it's available 
	on the project's <pythonpath> . 
	-->
	<class name="PySysTest" module="${testRootDir}/pysys-extensions/MySharedTestClass.py"/>

	<!-- You can customize the Input/Output/Reference directory names if you wish (or even provide an absolute 
	paths if needed). These can also be specified using the older names <output/input/reference> with a path= attribute. 
	-->
	<input-dir>${testRootDir}/pysys-extensions/my_shared_input_files</input-dir>
	<reference-dir>MyReference</reference-dir>
	<output-dir>MyOutput</output-dir>
	
	<data>
		<!-- The ability to add user-defined data to the test descriptor is mostly useful when using a 
		shared Python class for lots of tests. 
		
		Project properties (but not other user-data values) can be specified using ${...}, but only if the Python code 
		that's reading the user-data explicitly expands the properties (it's not automatic). 
		-->
		<user-data name="myTestDescriptorData" value="foobar"/>
		
		<!-- For long values such as paths the value can be specified in a text (or CDATA) node, and if the 
		value is to be converted to a list, newline and/or comma can be used as delimiters. -->
		<user-data name="myTestDescriptorPath">
			foo/foo-${os_myThirdPartyLibraryVersion}
			foo/bar, foo/baz
			<!-- Comments and whitespace are ignored when converting a string to a list. -->
			foo/bosh
		</user-data>

	</data>
	
	<!-- Specify traceability requirements implemented by this test. 
	
	You can use this for whatever makes sense in your project, but typically they would be defect or user story ids; 
	see examples below. 
	-->
	<requirement id="UserRequirement_1a"/> 
	<requirement id="UserRequirement_2c"/> 
	<requirement id="Performance"/>
	<requirement id="UserStory.XYZ-54321"/>

	<!-- NB: Existing tests may nest some of the above elements under elements such as 
	description/classification/data/traceability rather than directly under the pysystest node, but these extra 
	elements are no longer required (or recommended). 
	-->

</pysystest>
